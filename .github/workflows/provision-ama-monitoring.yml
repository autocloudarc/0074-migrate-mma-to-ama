# Use OpenID Connect to authenticate to Azure
# https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Cwindows#use-the-azure-login-action-with-openid-connect
# *** https://colinsalmcorner.com/using-oidc-with-terraform-in-github-actions/
# https://azure.github.io/azure-workload-identity/docs/topics/federated-identity-credential.html#federated-identity-credential-for-a-user-assigned-managed-identity

name: Migrate To Azure Monitoring Agent
on:
  push:
    branches:
    - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  pre-requisites:
    name: 'setup_worfklow'
    env:
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      uamiName: umi-ama-mig-001
      uamiResourceGroup: rgp-iac
      idySubscription: "1d790e78-7852-498d-8087-f5d48686a50e"
      mgtSubscription: "019181ad-6356-46c6-b584-444846096085"
      mgtResourceGroup: rg-management
      mgtLogAnalyticsWorkspace: log-management
      lawId: "11de000e-9725-45e5-9530-3e291e1654b1"
      rgpName: rgp-idy
      rgpLocation: centralus
      uamiLocation: eastus2
      uamiRoleAssignmentVmContrib: "Virtual Machine Contributor"
      uamiRoleAssignmentLogAnalyticsContrib: "Log Analytics Contributor"
      uamiRoleAssignmentArcContrib: "Azure Arc Connected Resource Administrator"
      azCliVer: 2.58.0
      tfVersion: 1.7.5
      bicepVer: 0.26.54
      tfWorkingdir: src/tfm
      skipUAMI: false # Set to true to skip UAMI creation, false to create UAMI if necessary
      skipDriveSpace: true # Set to true to skip drive space check, false to check drive space
      skipEndpointCheck: true # Set to true to skip endpoint check, false to check endpoint connectivity
      skipMMAStatus: false # Set to true to skip MMA status check, false to check MMA status
      skipDCRDownload: false # Set to true to skip DCR download, false to download DCR
      dcrUrl: 'https://raw.githubusercontent.com/microsoft/AzureMonitorCommunity/master/Azure%20Services/Azure%20Monitor/Agents/Migration%20Tools/DCR%20Config%20Generator/WorkspaceConfigToDCRMigrationTool.ps1'
      dcrOutputPath: az-scripts/WorkspaceConfigToDCRMigrationTool.ps1
      dcrExportPath: dcr-export
      dcrNamePrefix: dcr # For DCR migration tool generated templates
      remediate-dcr: rem-dcr 
      remediate-dcr-ext: rem-dcr-ext
      policy-asm-dcr: enable-ama-dcr
      policy-asm-dcr-ext: enable-ama-dcr-ext
      operation: apply # Allowable values: plan, apply, rollback

    runs-on: ubuntu-latest

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
        working-directory: ${{ env.tfWorkingdir }}

    steps:
    # Checkout the repository to the GitHub Actions runner
    - name: Checkout
      uses: actions/checkout@v3
    
    # Authenticate to Azure tenant using the Azure login action (OIDC). Based on umi: ama-umi-002
    - name: authenticate_to_azure_with_oidc
      uses: Azure/login@v1
      with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-AzPSSession: true
    
    # Create user-assigned managed identity (UAMI) and assign roles
    - name: create_umi_and_assign_roles
      if: ${{ env.skipUAMI == 'false' }}
      uses: Azure/CLI@v1
      with: 
        azcliversion: ${{ env.azCliVer }}
        inlineScript: |
          chmod +x $GITHUB_WORKSPACE/az-scripts/createAndAssignUAMI.sh
          $GITHUB_WORKSPACE/az-scripts/createAndAssignUAMI.sh
    
    # Get drive space on each VM to ensure there is enough space (at least 10GB) to install the Azure Monitoring Agent
    - name: 'get_drive_space'
      if: ${{ env.skipDriveSpace == 'false' }}
      uses: azure/powershell@v1
      with:
        inlineScript: |
          chmod +x az-scripts/Get-DriveSpace.ps1
          Select-AzSubscription -SubscriptionId ${{ env.idySubscription }}
          az-scripts/Get-DriveSpace.ps1
        azPSVersion: "latest"

    # Test connectivity to required endpoints from each VM
    - name: 'check_connection_results'
      if: ${{ env.skipEndpointCheck == 'false' }}
      uses: azure/powershell@v1
      with:
        inlineScript: |
          chmod +x az-scripts/Get-EndpointConnectionResult.ps1
          az-scripts/Get-EndpointConnectionResult.ps1
        azPSVersion: "latest"

    # Get Azure Monitor Agent installation status on each VM
    - name: 'get_mma_extension_status'
      uses: azure/powershell@v1
      with:
        inlineScript: |
          Select-AzSubscription -SubscriptionId ${{ env.idySubscription }}
          $vmList = (Get-AzVM -ResourceGroupName ${{ env.rgpName }}).Name
          foreach ($vmName in $vmList) 
          {
             $vmExtensions = (Get-AzVMExtension -ResourceGroupName ${{ env.rgpName }} -VMName $vmName).Name
            if ($vmExtensions -contains 'MicrosoftMonitoringAgent') 
            {
              Write-Host "VM: $vmName, Legacy MMA extension IS installed"
              Write-Host "Removing MMA extension from VM: $vmName"
              Remove-AzVMExtension -ResourceGroupName ${{ env.rgpName }} -VMName $vmName -Name "MicrosoftMonitoringAgent" -WhatIf -Verbose
            }
            else
            {
              Write-Host "VM: $vmName, Legacy MMA extension NOT installed" 
            }
          }
        azPSVersion: "latest"

    # Download the DCR generator script, comment out the Set-DeployOutputOnAzure function, and deploy the generated templates to create the DCRs
    - name: 'download_execute_dcr_generator_script'
      if: ${{ env.skipDCRDownload == 'false' }}
      uses: azure/powershell@v1
      with:
        inlineScript: |
          try { Invoke-WebRequest -Uri ${{ env.dcrUrl }} -OutFile ${{ env.dcrOutputPath }} -Verbose }
          catch { Write-Host "Failed to download DCR generator script" }
          (Get-Content -Path ${{ env.dcrOutputPath }}) -replace '^Set-DeployOutputOnAzure', '# Set-DeployOutputOnAzure' | Set-Content -Path ${{ env.dcrOutputPath }}
          chmod +x az-scripts/Get-EndpointConnectionResult.ps1
          az-scripts/WorkspaceConfigToDCRMigrationTool.ps1 -SubscriptionId ${{ env.mgtSubscription }} -ResourceGroupName ${{ env.mgtResourceGroup }} -WorkspaceName ${{ env.mgtLogAnalyticsWorkspace }} -DCRName ${{ env.dcrNamePrefix }} -OutputFolder ${{ env.dcrExportPath }} -Verbose 
          $outputFiles = (Get-ChildItem -Path ${{ env.dcrExportPath }}).FullName
          $templateFiles = $outputFiles | Where-Object { $_ -like "*template.json" }
          foreach ($templateFile in $templateFiles) 
          {
            Write-Host ('-'*100)
            Get-Content -Path $templateFile
            Write-Host ('-'*100)
            New-AzResourceGroupDeployment -ResourceGroupName ${{ env.mgtResourceGroup }} -TemplateFile $templateFile -Verbose
          }
        azPSVersion: "latest"

    # Setup Terraform (requires unzip on Ubuntu. Run 'sudo apt-get install unzip' on self-hosted runner)
    - name: 'terraform_setup'
      if: ${{ env.operation == 'plan' || env.operation == 'apply' || env.operation == 'rollback' }}
      id: setup  
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.tfVersion }}
        terraform_wrapper: true   

    # Check version
    - name: 'terraform_version_check'
      if: ${{ env.operation == 'plan' || env.operation == 'apply' || env.operation == 'rollback' }}
      id: version
      run: terraform version

    # Format
    - name: 'terraform_format'
      if: ${{ env.operation == 'plan' || env.operation == 'apply' || env.operation == 'rollback' }}
      id: format
      run: terraform fmt -recursive

    - name: 'terraform_init'
      if: ${{ env.operation == 'plan' || env.operation == 'apply' }}
      id: init
      run: terraform init
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_USE_OIDC: true

    # Plan   
    - name: 'terraform_plan'
      if: ${{ env.operation == 'plan' || env.operation == 'apply' || env.operation == 'rollback' }}
      id: plan
      run: terraform plan -lock=false -out=tfplan
      timeout-minutes: 20
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_USE_OIDC: true

    # Deploy
    - name: 'terraform_apply'
      if: ${{ env.operation == 'apply' }}
      id: apply
      run: terraform apply -auto-approve
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_USE_OIDC: true

    - name: "remediate_policy_set"
      if: ${{ env.operation == 'apply' }}
      uses: azure/cli@v2
      with:
        inlineScript: |
          az account set --subscription ${{ env.idySubscription }}
          az policy state trigger-scan --verbose
          az policy remediation create -g ${{ env.rgpName }} -n ${{ env.remediate-dcr }} --policy-assignment ${{ env.policy-asm-dcr }} --verbose
          az policy remediation create -g ${{ env.rgpName }} -n ${{ env.remediate-dcr-ext }} --policy-assignment ${{ env.policy-asm-dcr-ext }} --verbose
        azcliversion: ${{ env.azCliVer }}

    # Rollback
    - name: 'terraform_rollback'
      if: ${{ env.operation == 'rollback' }}
      id: rollback
      run: terraform apply -auto-approve
      env:
        ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
        ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ARM_USE_OIDC: true
